// 23322: 초콜릿 뺏어 먹기
//
// - 문제
// 연두는 N개의 통에 초콜릿을 담아서, 초콜릿의 개수가 오름차순이 되도록 일렬로 배열해 놓는다. 즉, (1번째 통의 초콜릿의 개수) ≤ (2번째 통의 초콜릿의 개수) ≤ ... ≤ (N번째 통의 초콜릿의 개수)이다.
// 효원이는 매일 조금씩 연두의 초콜릿을 몰래 뺏어 먹을 계획을 세우는 중이다. 연두는 매우 눈치가 없기 때문에, 하루에 한 번 다음의 전략을 사용해서 초콜릿을 먹는다면 절대 눈치채지 못할 것이다.
// K<i인 i를 골라, i-K번째 통에 있는 초콜릿의 개수와 똑같아질 때까지 i번째 통에서 초콜릿을 꺼내 먹는다.
// 그 후 통을 재정렬한다. 즉, 초콜릿의 개수가 오름차순이 되도록 통을 재배치 한다.
// 효원이는 연두가 눈치채지 못하는 선에서 최대한 많이, 그리고 최대한 빨리 초콜릿을 먹어 치우고 싶다. 과연 몇 개나 먹을 수 있을까?
//
// - 입력
// 첫 번째 줄에 통의 개수 N과 K가 주어진다. (1 ≤ K < N ≤ 2,000)
// 두 번째 줄에 초기에 i번째 통에 들어있는 초콜릿의 개수 a_1, a_2, ..., a_N이 주어진다. (1 ≤ a_1 ≤ a_2 ≤ ... ≤ a_N ≤ 2,000)
//
// - 출력
// 연두에게 들키지 않으면서 먹을 수 있는 초콜릿의 최대 개수와, 그 개수의 초콜릿을 먹기 위해 필요한 최소 날짜를 출력한다.

#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  int n, k, a = 0, b = 0;
  cin >> n >> k;
  vector<int> v(n);
  for (int i = 0; i < n; i++)
    cin >> v[i];
  sort(v.begin(), v.end());
  for (int i = 1; i < n; i++)
    if (v[i] > v[0]) {
      a += v[i] - v[0];
      b++;
    }
  cout << a << ' ' << b;
  return 0;
}